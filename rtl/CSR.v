`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////


    module CSR( //Control  and  Status  Registers
                input                clk,
                input         [2:0]  OP,     //CSRop с декодера. Jпределяет операцию, которая будет производиться над содержимым CSR по адресу A  
                input         [31:0] mcause, //from IC
                input         [31:0] pc,
                input         [11:0] A,      //для указания адреса регистра CSR, к которому будет произведено обращение. Подключен к старшим 12 битам инструкции, к imm. Инструкции типа I 
                input         [31:0] WD,     //rd1 с RF
                output  reg   [5:0]  mie,    //to IC 
                
                
                output  reg   [31:0] mtvec,  //адрес вектора прерывания
                output  reg   [31:0] mepc,
                output  reg   [31:0] rd,
                output               en_int_rst,
                input                en_mepc,
                input         [31:0] mepc_csr
          );

/*Для  работы  с  регистрами  CSR  используются  специальные  инструкции !!!!!!SYSTEM (1110011) I-типа,
 хранящие в 12-битном поле imm адрес регистра, к которому будет осуществлен доступ 
и адреса в регистровом файле от куда бу-дет считан или куда будет записан один из регистров CSR.*/

/*  верхние  4  бита  адреса  CSR  используются  для  кодирования доступности CSR для чтения и записи в соответствии с уровнем привилегий: 
два верхних бита imm[11:10] указывают, доступен ли регистр для чтения/за-писи или только для чтения, 
следующие два бита imm[9:8] кодируют самый низ-кий уровень привилегий, который может получить доступ к CSR. */

reg en_mie = 0;
reg en_mtvec = 0;
reg en_mscratch = 0;
//reg en_mepc = 0;
reg en_cause = 0;

wire mux_en_pc;
wire mux_en_cause;
assign mux_en_pc    = (OP[2] || OP[1] || OP[0]);
assign mux_en_cause = (OP[2] || OP[1] || OP[0]);

//Демультиплексор дешифрующий адрес и передающий сигнал разрешения на запись enable (EN) на тот же регистр.
always  @(*) //ДАЁТ РЕГИСТРАМ РАБОТАТЬ

case(A)
  12'h304: en_mie      <= OP[1] || OP[0];    //machine interrapt enable register.  Регистр, позволяющий маскировать прерывания. Например, если на 5-ом входе системы прерывания генерируется прерывание, то процессор отреагирует на него только в том случае, если 5-ый бит регистра mie будет равен 1. 
  12'h305: en_mtvec    <= OP[1] || OP[0]; //...trap-handler(обработчик) base address 
  12'h340: en_mscratch <= OP[1] || OP[0]; //Указатель на верхушку стека. Стек для прерывания находится не там же, где программный стек, а адрес начала этого стека хра-нится в регистре mscratch
 // 12'h041: en_mepc     <= mux_en_pc;     //...exception pc. Сохраняет адрес инструкции, во время которой произошло прерывание или исключение. ТЕКУЩИЙ
  12'h342: en_cause    <= mux_en_cause;  
  default: begin
             en_mie      = 0;
             en_mtvec    = 0;
             en_mscratch = 0;
      //       en_mepc     = 0;
             en_cause    = 0;
           end  
endcase   

//ЕСТЬ ЛИ ПРЕРЫВАНИЯ
//Что именно будет записано в регистр CSR
wire [31:0] mux;
assign mux = (OP[1:0] == 2'b00) ? 32'b0 : //без разницы
             (OP[1:0] == 2'b01) ? WD :    //значение с RF
             (OP[1:0] == 2'b10) ? (rd && ~WD) : (rd || WD);  //между регистром из CSR и значением из регистрового файла

reg [31:0] cause;
//нужны,  чтобы  при  возникновении  сигнала  прерывания  сразу  же  разрешить обновить значение этих регистров значением PC, на котором произошло пре-рывание и кодом причины происходящего сейчас прерывания. 
wire [31:0] mux_mepc;
wire [31:0] mux_cause;
//assign mux_mepc    = (OP[2]) ? pc - 32'h4 : mux; 
//assign mux_cause   = (OP[2]) ? mcause : mux;

reg [31:0] mscratch; //адрес вершины стека прерываний
assign en_int_rst = (mie === 6'bx || mtvec === 32'bx || mscratch === 32'bx); //И ЧТОБЫ RF НЕ БЫЛ В Х

always @(posedge clk) begin
if(en_mepc)     
      mepc <= mepc_csr;
else  mepc <= mepc;
if(en_cause)    
      cause    <= mcause;
else  cause <= cause;
if(en_mie)      
      mie      <= mux;
else  mie  <= mie;
if(en_mtvec)    
      mtvec    <= mux;
else  mtvec <= mtvec;
if(en_mscratch) 
      mscratch <= mux;
else  mscratch <= mscratch;
end 


//Мультиплексор, обеспечивающий дешифрацию адреса и подачу на выход RD значения соответствующего регистра   
always @(*) //ПОДАЁТ НУЖНЫЙ РЕГИСТР НА ВЫХОД
case(A)
  12'h304: rd <= mie;   //machine interrapt enable register.  Регистр, позволяющий маскировать прерывания. Например, если на 5-ом входе системы прерывания генерируется прерывание, то процессор отреагирует на него только в том случае, если 5-ый бит регистра mie будет равен 1. 
  12'h305: rd <= mtvec; //...trap-handler(обработчик) base address 
  12'h340: rd <= mscratch; //Указатель на верхушку стека. Стек для прерывания находится не там же, где программный стек, а адрес начала этого стека хра-нится в регистре mscratch
  12'h041: rd <= mepc;     //...exception pc. Сохраняет адрес инструкции, во время которой произошло прерывание или исключение. ТЕКУЩИЙ
  12'h342: rd <= cause;  
  default: rd <= 32'd0; 
endcase
      
endmodule
