#.globl __start

#       mie, 0x304
#       mtvec, 0x305
#       mscratch, 0x340
#       mcause, 0x342
#       mepc, 0x341

.text   #ПРИМЕР ПРОГРАММЫ ОБРАБОТЧИКА ПРЕРЫВАНИЙ

start:      
            li    sp, 0x7fffeffc      # li    sp, 0xFFFFFFFC      # устанавливаем указатель на верхушку стека         sp = 0x7fffeffc
            li    gp, 0x10008000      # li    gp, 0x10000000      # устанавливаем указатель на глобальные данные      gp = 0x10008000
	    
       
            li     t0, 0x28     # подготавливаем маску прерывания для 5 и 3 входов 101000 
            csrw   t0, 0x304 #mie            # uie  для проверки          # загружаем маску в регистр маски 
            la     t0, interrupt      # аналогично li загружает число, в данном случае - адреc interrapt
            csrw   t0, 0x305 #mtvec          # устанавливаем вектор прерывания  utvec = t0
            li     t0, 0x7fffeee0     # готовим адрес верхушки стека прерывания
            csrw   t0, 0x340 #mscratch       # csrw  mscratch, t0          # загружаем в указатель на верхушку стека прерывания 

            #la     t0, while    
            #csrw   t0, 0x341    
         
            
            li    t0, 10              # начальное значение глобальной переменной 
            sw    t0, 0(gp)           # загружаем переменную в память  
            
            li    t1, 3               # начальное значение, чтобы в симуляции не было xxx 
           #  csrw  t1, 0x342 #mcause
            li    t2, 10              # начальное значение, чтобы в симуляции не было xxx
            
#while:                                # бесконечный цикл, аналогичный while (1); 
          #   csrw  pc, uepc
         #    beq x0, x0, interrupt    # ничего не делаем
                      
                          # ОБРАБОТЧИК ПРЕРЫВАНИЯ 
                        # Сохраняем используемые регистры на стек
interrupt: 
            csrrw t0, 0x340, t0       # меняем местами mscratch и t0 mscratch
            sw    t1, 0(t0)           # сохраняем t1 на стек mscratch
            sw    t2, 4(t0)           # сохраняем t2 на стек mscratch
            	
                        # Проверяем регистр причины и на 3-е прерывание
            csrr  t1, 0x342 #mcause          # t1 = mcause 
            li    t2, 3               # t2 = 3 (код одного из прерываний) 
            bne   t1, t2, fifth       # если это не 3 прерывание, то проверяем 5
            
                        # Обработчик 3-го прерывания То, как мы обработаем прерывание
            lw    t2, 0(gp)           # загружаем переменную из памяти
            addi  t2, t2, 3           # прибавляем к значению 3
            sw    t2, 0(gp)           # возвращаем переменную в память
            j     done                # идем возвращать регистры и на выход 
            
fifth:                 # Проверяем на 5-ое прерывание
            
            li    t2, 5               # t2 = 5 (код  другого прерывания) 
            bne   t1, t2, done        #если не 5-ое, то выходим
            
                       # Обработчик 5-го прерывания
            lw    t2, 0(gp)           # загружаем переменную из памяти
            srli  t2, t2, 1           # делим число пополам сдвигом вправо
            sw    t2, 0(gp)           # возвращаем переменную в память
            j     done                # идем возвращать регистры и на выход
            
                        # Возвращаем регистры на места и выходим 
done:       lw    t1, 0(t0)           # возвращаем t1 со стека 
            lw    t2, 4(t0)           # возвращаем t2 со стека 
            csrrw t0, 0x340, t0       # меняем обратно местами t0 и mscratch
            uret                      # возвращаем управление программе (pc = mepc) 
